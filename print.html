<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cargo Vet</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="motivation.html"><strong aria-hidden="true">1.1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="how-it-works.html"><strong aria-hidden="true">1.2.</strong> How it Works</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">2.2.</strong> Setup</a></li><li class="chapter-item expanded "><a href="audit-criteria.html"><strong aria-hidden="true">2.3.</strong> Audit Criteria</a></li><li class="chapter-item expanded "><a href="importing-audits.html"><strong aria-hidden="true">2.4.</strong> Importing Audits</a></li><li class="chapter-item expanded "><a href="recording-audits.html"><strong aria-hidden="true">2.5.</strong> Recording Audits</a></li><li class="chapter-item expanded "><a href="performing-audits.html"><strong aria-hidden="true">2.6.</strong> Performing Audits</a></li><li class="chapter-item expanded "><a href="specifying-policies.html"><strong aria-hidden="true">2.7.</strong> Specifying Policies</a></li><li class="chapter-item expanded "><a href="multiple-repositories.html"><strong aria-hidden="true">2.8.</strong> Multiple Repositories</a></li><li class="chapter-item expanded "><a href="configuring-ci.html"><strong aria-hidden="true">2.9.</strong> Configuring CI</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">3.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">3.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="audit-entries.html"><strong aria-hidden="true">3.2.</strong> Audit Entries</a></li><li class="chapter-item expanded "><a href="built-in-criteria.html"><strong aria-hidden="true">3.3.</strong> Built-In Criteria</a></li><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">3.4.</strong> Commands</a></li><li class="chapter-item expanded "><a href="how-vetting-works.html"><strong aria-hidden="true">3.5.</strong> How Vetting Works</a></li><li class="chapter-item expanded "><a href="design-choice-faq.html"><strong aria-hidden="true">3.6.</strong> Design Choice FAQ</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cargo Vet</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cargo-vet"><a class="header" href="#cargo-vet">Cargo Vet</a></h1>
<p>The <code>cargo vet</code> subcommand is a tool to help projects ensure that third-party
Rust dependencies have been audited by a trusted entity. It strives to be
lightweight and easy to integrate.</p>
<p>When run, <code>cargo vet</code> matches all of a project's third-party dependencies
against a set of audits performed by the project authors or entities they trust.
If there are any gaps, the tool provides mechanical assistance in performing and
documenting the audit.</p>
<p>The primary reason that people do not ordinarily audit open-source dependencies
is that it is too much work. There are a few key ways that <code>cargo vet</code> aims to
reduce developer effort to a manageable level:</p>
<ul>
<li>
<p><strong>Sharing</strong>: Public crates are often used by many projects. These projects can
share their findings with each other to avoid duplicating work.</p>
</li>
<li>
<p><strong>Relative Audits</strong>: Different versions of the same crate are often quite similar
to each other. Developers can inspect the difference between two versions, and record
that if the first version was vetted, the second can be considered vetted as well.</p>
</li>
<li>
<p><strong>Deferred Audits</strong>: It is not always practical to achieve full coverage.
Dependencies can be added to a list of exceptions which can be ratcheted down
over time. This makes it trivial to introduce <code>cargo vet</code> to a new project and
guard against future vulnerabilities while vetting the pre-existing code
gradually as time permits.</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: <code>cargo vet</code> is under active development. If you're interested in
deploying it, <a href="mailto:bholley@mozilla.com">get in touch</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>The discussion below covers the high-level motivation for building this system. If
you're just interested in how it works, you can skip to the next section.</p>
<h3 id="security-risks-of-third-party-code"><a class="header" href="#security-risks-of-third-party-code">Security Risks of Third-Party Code</a></h3>
<p>Low-friction reuse of third-party components — via systems like crates.io or npm — is
an essential element of modern software development. Unfortunately, it also
widens the set of actors who can introduce a security vulnerability into the final
product.</p>
<p>These defects can be honest mistakes, or intentional supply-chain attacks. They
can exist in the initial version, or be introduced later as an update. They can
be introduced by the original author, or by a new maintainer
who acquires control over the release of subsequent versions.
Taken together, these avenues constitute a demonstrated and growing
risk to software security.</p>
<p>Ideally, the composition model would include technical guarantees to isolate
components from each other and prevent a defect in one component from compromising
the security of the entire program (e.g. <a href="https://bytecodealliance.org/articles/announcing-the-bytecode-alliance">WebAssembly nanoprocesses</a>).
However, that is often not a realistic solution for many projects today. In the absence
of technical guarantees, the responsibility for ensuring software integrity falls to
humans. But reviewing every line of third-party code can be very time-consuming and
difficult, and undermines the original premise of low-friction code reuse. Practically
speaking, it often just doesn't happen — even at large well-resourced companies.</p>
<h3 id="tackling-this-in-rust"><a class="header" href="#tackling-this-in-rust">Tackling This in Rust</a></h3>
<p>There are two properties of Rust that make this problem easier to solve.</p>
<p>First, it's relatively easy to audit Rust code. Unlike C/C++, Rust code is
memory-safe by default, and unlike JavaScript, there is no highly-dynamic shared
global environment. This means that you can often reason at a high level about
the range of a module's potential behavior without carefully studying all of its
internal invariants. For example, a complicated string parser with a narrow
interface, no unsafe code, and no powerful imports has limited means to
compromise the rest of the program. This also makes it easier to conclude that a
new version is safe based on a diff from a prior trusted version.</p>
<p>Second, nearly everyone in the Rust ecosystem relies on the same set of basic tooling
— Cargo and crates.io — to import and manage third-party components, and there is high
overlap in the dependency sets. For example, at the time of writing,
<a href="https://hg.mozilla.org/mozilla-central/file/add572d6012047244d022436e0b5c578b3dd7cf7/Cargo.lock">Firefox</a>,
<a href="https://github.com/bytecodealliance/wasmtime/blob/49c2b1e60a87623796046176500bed6afa956d2f/Cargo.lock">wasmtime</a>,
and <a href="https://github.com/rust-lang/rust/blob/532d3cda90b8a729cd982548649d32803d265052/Cargo.lock">the Rust compiler</a>
specified 406, 310, and 357 crates.io dependencies respectively<sup class="footnote-reference"><a href="#1">1</a></sup>. Ignoring
version, each project shares about half of its dependencies with at least one of
the other two projects, and 107 dependencies are common across all three.</p>
<p>This creates opportunities to share the analysis burden in an systematic way. If you're able to
discover that a trusted party has already audited the exact crate release you're using,
you can gain quite a bit of confidence in its integrity with no additional effort. If
that part has audited a different version, you could consider either switching to it, or
merely auditing the diff between the two. Not every organization
and project share the same level of risk tolerance, but there is a lot of common
ground, and substantial room for improvement beyond no sharing at all.</p>
<h2 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The following command string computes the names of the crates.io packages
specified in <code>Cargo.lock</code>. Note the filtering for path and git dependencies,
along with removing duplicates due to different versions of the same crate:</p>
</div>
<pre><code>cat Cargo.lock | grep -e &quot;name = &quot; -e &quot;source = \&quot;registry&quot; | awk '/source =/ { print prv_line; next } { prv_line = $0 }' | sort | uniq
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-it-works"><a class="header" href="#how-it-works">How it Works</a></h1>
<p>Most developers are busy people with limited energy to devote to supply-chain
integrity. Therefore, the driving principle behind cargo-vet is to minimize
friction and make it as easy as possible to do the right thing. It aims to be
trivial to set up, fit unobtrusively into existing workflows, guide people
through each step, and allow the entire ecosystem to share the work of auditing
widely-used packages.</p>
<p>This section provides a high-level overview of how the system operates to
achieve these goals.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<!-- diagrams: https://docs.google.com/presentation/d/18svkEsm9K5gLQeJLfILGdMUTsujiDgzecrswcOAdceQ/edit -->
<p>Cargo-vet is easy to set up. Most users will already have a repository with some
pre-existing third-party dependencies:</p>
<p><img src="images/existing_repo.png" alt="Existing Repository" /></p>
<p>Cargo-vet can enabled by adding the tool as a linter and running <code>cargo vet init</code>, which creates some metadata in the repository:</p>
<p><img src="images/with_metadata.png" alt="Repository with Metadata" /></p>
<p>This takes about five minutes, and crucially, does not require auditing the
existing dependencies. These are automatically added to the exemptions list:</p>
<p><img src="images/exemptions.png" alt="Exemptions" /></p>
<p>This makes it low-effort to get started, and facilitates tackling the backlog
incrementally from an approved state.</p>
<h2 id="adding-new-third-party-code"><a class="header" href="#adding-new-third-party-code">Adding New Third-Party Code</a></h2>
<p>Sometime later, a developer attempts to pull new third-party code into the
project. This might be a new dependency, or an update to an existing one:</p>
<p><img src="images/changeset.png" alt="Changeset" /></p>
<p>As part of continuous integration, cargo-vet analyzes the updated build graph to
verify that the new code has been audited by a trusted organization. If not, the
patch is refused:</p>
<p><img src="images/refusal.png" alt="Refusal" /></p>
<p>Next, cargo-vet assists the developer in resolving the situation.  First, it
scans the registry to see if any well-known organizations have audited that
package before:</p>
<p><img src="images/potential_imports.png" alt="Potential Imports" /></p>
<p>If there’s a match, cargo-vet informs the developer and offers the option to add
that organization to the project’s trusted imports:</p>
<p><img src="images/import.png" alt="Import" /></p>
<p>This enables projects to lazily build up an increasingly wide set of approved
crates. Approval of both import and audit submissions automatically falls to the
code owners of the <code>supply-chain/</code> directory, which should consist of either
project leadership or a dedicated security team.</p>
<h2 id="auditing-workflow"><a class="header" href="#auditing-workflow">Auditing Workflow</a></h2>
<p>It may of course be the case that the developer needs to perform the audit
themselves, and cargo-vet streamlines this process. Often someone will have
already audited a different version of the same crate, in which case cargo-vet
computes the relevant diffs and identifies the smallest one<sup class="footnote-reference"><a href="#1">1</a></sup>. After walking
the developer through the process of determining what to audit, it then presents
the relevant artifacts for inspection, either locally or on
<a href="https://sourcegraph.com">Sourcegraph</a>.</p>
<p>Cargo-vet minimizes developer friction by storing audits in-tree. This means
that developers don’t need to navigate or authenticate with an external system.
Interactions with cargo-vet are generally triggered when a developer creates a
changeset adding new third-party code, and this design allows them to simply
submit the relevant audits as part of that changeset:</p>
<p><img src="images/audit_submission.png" alt="Audit Submission" /></p>
<h2 id="sharing-the-work"><a class="header" href="#sharing-the-work">Sharing the Work</a></h2>
<p>Cargo-vet’s mechanisms for sharing and discovery are built on top of this
decentralized storage. Imports are implementing by pointing directly to the
audit files in external repositories, and the registry is merely an index of
such files from well-known organizations:</p>
<p><img src="images/registry.png" alt="Registry" /></p>
<p>This also means there’s no central infrastructure for an attacker to compromise.
Imports used to vet the dependency graph are always fetched directly from the
relevant organization, and only after explicitly adding that organization to the
trusted set.</p>
<p>Audit sharing is a key force-multiplier behind <code>cargo vet</code>, but it is not
essential. Projects can of course decline to add any imports and perform all
audits themselves.</p>
<h2 id="additional-features"><a class="header" href="#additional-features">Additional Features</a></h2>
<p>Cargo-vet has a number of advanced features under the hood — it supports custom
audit criteria, configurable policies for different subtrees in the build graph,
and filtering out platform-specific code. These features are all completely
optional, and the baseline experience is designed to be simple and require
minimal onboarding. You can learn more about them in the subsequent chapters of
this book.</p>
<h2 id="footnotes-1"><a class="header" href="#footnotes-1">Footnotes</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Differential audits work even for crates in the exemptions list. While it
might seem counter-intuitive to perform a relative security audit against an
unknown base, doing so still provides meaningful protection against future
supply-chain attacks.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>This chapter walks through the steps of deploying and using <code>cargo vet</code>, with
a survey of its key features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<blockquote>
<p><strong>Note</strong>: Since <code>cargo vet</code> is under rapid development, we have intentionally
left the crates.io package as a placeholder to signal that it is not quite
ready for general use. Firefox developers can access the tool by invoking
<code>./mach cargo vet</code>, and anyone eager to try it out is welcome to pull the
repository and invoke <code>cargo install --path .</code> Bug reports welcome!</p>
<p>We aim to publish a proper release in the coming weeks, and appreciate your
patience. Once we do, the following instructions will become the canonical way
to install <code>cargo vet</code>.</p>
</blockquote>
<p>Installing <code>cargo vet</code> can be done through Cargo:</p>
<pre><code>$ cargo install cargo-vet
</code></pre>
<p>Afterwards you can confirm that it's installed via:</p>
<pre><code>$ cargo vet --version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-1"><a class="header" href="#setup-1">Setup</a></h1>
<p>Now that you've installed <code>cargo vet</code>, you're ready to set it up for your project. Move
into the top-level project directory and execute the following:</p>
<pre><code>$ cargo vet
  error: cargo vet is not configured
</code></pre>
<p>To be useful, <code>cargo vet</code> needs to know which audits have been performed and
what policy should be enforced. By default, this information is stored next to
<code>Cargo.lock</code> in a directory called <code>supply-chain</code>. This location is
<a href="./config.html">configurable</a>.</p>
<p>To get started, you can invoke:</p>
<pre><code>$ cargo vet init
</code></pre>
<p>This creates and populates the <code>supply-chain</code> directory. It contains two files:
<code>audits.toml</code> and <code>config.toml</code>. The <code>unaudited</code> table of <code>config.toml</code> is
populated with the full list of third-party crates currently used by the
project. The files in this directory should be added to version control along
with <code>Cargo.lock</code>.</p>
<p>Now, try vetting again:</p>
<pre><code>$ cargo vet
  Vetting Succeeded (0 audited, X unaudited)
</code></pre>
<p>You're now up and running, though with an empty audit set: vetting only succeeds
because your list of exceptions contains the exact set of current dependencies
used in your project. Generally speaking, you should try to avoid more
exceptions, and ideally seek to shrink the list over time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audit-criteria"><a class="header" href="#audit-criteria">Audit Criteria</a></h1>
<p>Before you can go about auditing code, you need to decide what you want the
audits to entail. This is expressed with &quot;audit criteria&quot;, which are just labels
corresponding to human-readable descriptions of what to check for.</p>
<p><code>cargo vet</code> comes pre-equipped with two built-in criteria:
<a href="built-in-criteria.html#safe-to-run">safe-to-run</a> and
<a href="built-in-criteria.html#safe-to-deploy">safe-to-deploy</a>. You can use these without
any additional configuration.</p>
<h2 id="custom-criteria"><a class="header" href="#custom-criteria">Custom Criteria</a></h2>
<p>You can also specify arbitrary custom criteria in <code>audits.toml</code>. For example:</p>
<pre><code>[criteria.crypto-reviewed]
description = '''
The cryptographic code in this crate has been reviewed for correctness by a
member of a designated set of cryptography experts within the project.
'''
</code></pre>
<p>The full feature set is documented <a href="config.html#the-criteria-table">here</a>.</p>
<h2 id="multiple-sets-of-criteria"><a class="header" href="#multiple-sets-of-criteria">Multiple Sets of Criteria</a></h2>
<p>There are a number of reasons you might wish to operate with multiple sets of
criteria:</p>
<ul>
<li><strong>Applying extra checks to some crates:</strong> For example, you might define
<code>crypto-reviewed</code> criteria and require them for audits of crates which
implement cryptographic algorithms that your application depends on.</li>
<li><strong>Relaxing your audit requirements for some crates:</strong> For example, you might
decide that crates not exposed in production can just be <code>safe-to-run</code>
rather than <code>safe-to-deploy</code>, since they don't need to be audited for handling
adversarial input.</li>
<li><strong>Improving Sharing:</strong> If one project wants to audit for issues A and B, and
another project want to audit for B and C, defining separate sets of criteria
for A, B, and C allows the two projects to partially share work.</li>
</ul>
<p>You can define and use as many separate sets of criteria as you like.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="importing-audits"><a class="header" href="#importing-audits">Importing Audits</a></h1>
<p>The fastest way to shrink the <code>unaudited</code> list is to pull in the audit sets from
other projects that you trust via <code>imports</code> directives in <code>config.toml</code>.  This
directive allows you to virtually merge audit lists from other projects into
your own:</p>
<pre><code>[imports.foo]
url = &quot;https://raw.githubusercontent.com/foo-team/foo/main/supply-chain/audits.toml&quot;

[imports.bar]
url = &quot;https://hg.bar.org/repo/raw-file/tip/supply-chain/audits.toml&quot;
</code></pre>
<p>Upon invocation, <code>cargo vet</code> will fetch each url, extract the relevant data, and
store the information in <code>imports.lock</code>. Similar to <code>cargo vendor</code>, passing
<code>--locked</code> will skip the fetch.</p>
<p>Note that this mechanism is not transitive — you can't directly import someone
else's list of imports. This is an intentional limitation which keeps trust
relationships direct and easy to reason about. That said, you can always inspect
the <code>config.toml</code> of other projects for inspiration, and explicitly adopt any
<code>imports</code> entries that meet your requirements.</p>
<p>The <a href="built-in-criteria.html">built-in criteria</a> have the same meaning across all
projects, so importing an audit for <code>safe-to-run</code> has the same effect as
appending that same audit to your own <code>audits.toml</code>. By default, custom criteria
defined in a foreign audit file exist in a private namespace and have no meaning
in the local project. However, they can be <a href="config.html#criteria-map">mapped</a> as
desired to locally-defined criteria.</p>
<h2 id="the-registry"><a class="header" href="#the-registry">The Registry</a></h2>
<p>To ease discovery, <code>cargo vet</code> maintains a central registry of the audit sets
published by well-known organizations. This information is stored in the
<a href="https://raw.githubusercontent.com/bholley/cargo-vet/main/registry.toml"><code>registry.toml</code></a>
file alongside the source code in the <code>cargo vet</code>
<a href="https://github.com/bholley/cargo-vet">repository</a>. You can request the
inclusion of your audit set in the registry by submitting a pull request.</p>
<p>You can inspect the registry directly to find audit sets you wish to import.
Moreover, when suggesting audits, <code>cargo vet</code> will fetch the sets listed in the
registry and surface any entries that could be imported to address the
identified gaps. This is described later <a href="performing-audits.html#suggestions-from-the-registry">in more
detail</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-audits"><a class="header" href="#recording-audits">Recording Audits</a></h1>
<p>Audits of your project's dependencies performed by you or your teammates are
recorded in <code>audits.toml</code>. Note that these dependencies may have their own
<code>audits.toml</code> files if they also happen to use <code>cargo vet</code>, but these have no
effect on your project unless you explicitly import them in <code>config.toml</code>.</p>
<h2 id="auditstoml"><a class="header" href="#auditstoml"><code>audits.toml</code></a></h2>
<p>Listing a crate in <code>audits.toml</code> means that the you've inspected it and
determined that it meets the specified criteria.</p>
<p>Each crate can have one or more audit entries, which support various fields.
Specifying a <code>version</code> means that the owner has audited that version in its
entirety. Specifying a <code>delta</code> means that the owner has audited the diff between
the two versions, and determined that the changes preserve the relevant
properties.</p>
<p>If, in the course of your auditing, you find a crate that does <em>not</em> meet the
criteria, you can note this as well with <code>violation</code>.</p>
<p>A sample <code>audits.toml</code> looks like this:</p>
<pre><code>[criteria]

...

[[audits.bar]]
version = &quot;1.2.3&quot;
who = &quot;Alice Foo &lt;alicefoo@example.com&gt;&quot;
criteria = &quot;safe-to-deploy&quot;

[[audits.bar]]
delta = &quot;1.2.3 -&gt; 1.2.4&quot;
who = &quot;Bob Bar &lt;bobbar@example.com&gt;&quot;&quot;
criteria = &quot;safe-to-deploy&quot;

[[audits.bar]]
version = &quot;2.1.3&quot;
who = &quot;Alice Foo &lt;alicefoo@example.com&gt;&quot;
criteria = &quot;safe-to-deploy&quot;

[[audits.bar]]
delta = &quot;2.1.3 -&gt; 2.1.1&quot;
who = &quot;Alice Foo &lt;alicefoo@example.com&gt;&quot;
criteria = &quot;safe-to-deploy&quot;

[[audits.baz]]
version = &quot;0.2&quot;
who = &quot;Alice Foo &lt;alicefoo@example.com&gt;&quot;
criteria = &quot;safe-to-run&quot;

[[audits.foo]]
version = &quot;0.2.1 -&gt; 0.3.1&quot;
who = &quot;Bob Bar &lt;bobbar@example.com&gt;&quot;&quot;
criteria = &quot;safe-to-deploy&quot;

[[audits.malicious_crate]]
violation = &quot;*&quot;
who = &quot;Bob Bar &lt;bobbar@example.com&gt;&quot;&quot;
criteria = &quot;safe-to-run&quot;

[[audits.partially_vulnerable_crate]]
violation = &quot;&gt;=2.0, &lt;2.3&quot;
who = &quot;Bob Bar &lt;bobbar@example.com&gt;&quot;&quot;
criteria = &quot;safe-to-deploy&quot;
</code></pre>
<p>Exactly one of <code>version</code>, <code>delta</code>, or <code>violation</code> must be specified for each
entry.</p>
<p>The expectation is that this file should never be pruned unless a
previously-recorded entry is determined to have been erroneous. Even if the
owner no longer uses the specified crates, the audit records can still prove
useful to others in the ecosystem.</p>
<h2 id="the-unaudited-table-in-configtoml"><a class="header" href="#the-unaudited-table-in-configtoml">The <code>unaudited</code> table in <code>config.toml</code></a></h2>
<p>This table enumerates the dependencies that have not been audited, but which the
project is nonetheless using. The structure is generally the same as the
<code>audits</code> table, with a <a href="config.html#the-unaudited-table">few differences</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performing-audits"><a class="header" href="#performing-audits">Performing Audits</a></h1>
<p>Human attention is a precious resource, so <code>cargo vet</code> provides several features
to spend that attention as efficiently as possibly.</p>
<h2 id="managing-dependency-changes"><a class="header" href="#managing-dependency-changes">Managing Dependency Changes</a></h2>
<p>When you run <code>cargo update</code>, you generally pull in new crates or new versions of
existing crates, which may cause <code>cargo vet</code> to fail. In this situation,
<code>cargo vet</code> identifies the relevant crates and recommends how to audit them:</p>
<pre><code>$ cargo update
  ....

$ cargo vet
  Vetting Failed!

  3 unvetted dependencies:
      bar:1.5 missing [&quot;safe-to-deploy&quot;]
      baz:1.3 missing [&quot;safe-to-deploy&quot;]
      foo:1.2.1 missing [&quot;safe-to-deploy&quot;]

  recommended audits for safe-to-deploy:
      cargo vet diff foo 1.2 1.2.1  (10 lines)
      cargo vet diff bar 2.1.1 1.5  (253 lines)
      cargo vet inspect baz 1.3     (2033 lines)

  estimated audit backlog: 2296 lines

  Use |cargo vet certify| to record the audits.
</code></pre>
<p>Note that if other versions of a given crate have already been verified, there
will be multiple ways to perform the review: either from scratch, or relative to
one or more already-audited versions. In these cases, <code>cargo vet</code>
computes all the possible approaches and selects the smallest one.</p>
<p>You can, of course, choose to add one or more unvetted dependencies to the
<code>unaudited</code> list instead of auditing them. This may be expedient in some
situations, though doing so frequently undermines the value provided by the
tool.</p>
<h2 id="inspecting-crates"><a class="header" href="#inspecting-crates">Inspecting Crates</a></h2>
<p>Once you've identified the audit you wish to perform, the next step is to
produce the artifacts for inspection. This is less trivial than it might sound:
even if the project is hosted somewhere like GitHub, there's no guarantee that
the code in the repository matches the bits submitted to crates.io. And the
packages on crates.io aren't easy to download manually.</p>
<p>To make this easy, the <code>cargo vet inspect</code> subcommand will ensure the crate has
been downloaded to your local registry cache and drop your terminal into the
appropriate directory to inspect it with whatever tools you like. When you
finish the audit, you can use <code>cargo vet certify</code> to add the entry to
<code>audits.toml</code>:</p>
<pre><code>$ cargo vet inspect baz 1.3
  Opening nested shell in ~/.cargo/registry/src/github.com-1ecc6299db9ec823/baz-1.3
  Use `exit` or Ctrl-D to finish.
$ ...
$ exit
$ cargo vet certify baz 1.3

  I, Alice, certify that I have audited version 1.3 of baz in accordance with
  the following criteria:

  ...

 (type &quot;yes&quot; to certify): yes

  Recorded full audit of baz version 1.3
</code></pre>
<p>Similarly, <code>cargo vet diff</code> will fetch two versions of a given crate, compare
them, and output a git-compatible diff between the two:</p>
<pre><code>$ cargo vet diff foo 1.2 1.2.1
  (Diff printed to stdout)
$ ...
$ cargo vet certify foo 1.2 1.2.1

  I, Alice, certify that I have audited the changes between versions 1.2 and
  1.2.1 of baz in accordance with the following criteria:

  ...

  (type &quot;yes&quot; to certify): yes

  Recorded relative audit between foo versions 1.2 and 1.2.1
</code></pre>
<p>In the future, it may be valuable to stand up a web service to provide a richer
display of the differences between public crates. However, since auditing is
usually a much lighter-weight process than full code review, this functionality
is not essential.</p>
<h2 id="shrinking-the-unaudited-table"><a class="header" href="#shrinking-the-unaudited-table">Shrinking the <code>unaudited</code> Table</a></h2>
<p>Even when your project is passing <code>cargo vet</code>, lingering entries in <code>unaudited</code>
could still leave you vulnerable. As such, shrinking it is a worthwhile endeavor.</p>
<p>Any malicious crate can compromise your program, but not every crate requires
the same amount of effort to verify. Some crates are larger than others, and
different versions of the same crate are usually quite similar. To take
advantage of this, <code>cargo vet suggest</code> can estimate the lowest-effort audits
you can perform to reduce the number of entries in <code>unaudited</code>, and
consequently, your attack surface.</p>
<p>More precisely, <code>cargo vet suggest</code> computes the number of lines that would need
to be reviewed for each unaudited dependency, and displays them in order. This
is the same information you'd get if you emptied out <code>unaudited</code> and re-ran
<code>cargo vet</code>.</p>
<h2 id="suggestions-from-the-registry"><a class="header" href="#suggestions-from-the-registry">Suggestions from the Registry</a></h2>
<p>When <code>cargo vet</code> suggests audits — either after a failed vet or during <code>cargo vet suggest</code> — it also fetches the contents of the
<a href="importing-audits.html#the-registry">registry</a> and checks whether any of the
available sets contain audits which would fill some or all of the gap. If so, it
enumerates them so that the developer can consider importing them in lieu of
performing the entire audit themselves:</p>
<pre><code>$ cargo vet suggest
  recommended audits for safe-to-deploy:
      cargo vet inspect baz 1.3  (2033 lines)
        Note: &quot;firefox&quot; contains an audit for baz 1.2, consider importing it.

  estimated audit backlog: 2033 lines

  Use |cargo vet certify| to record the audits.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifying-policies"><a class="header" href="#specifying-policies">Specifying Policies</a></h1>
<p>By default, <code>cargo vet</code> checks all transitive dependencies of all top-level
crates against the following criteria on all-platforms:</p>
<ul>
<li>For regular dependencies: <code>safe-to-deploy</code></li>
<li>For dev-dependencies and build-dependencies: <code>safe-to-run</code></li>
</ul>
<p>In some situations, you may be able to reduce your workload by encoding your
requirements more precisely, such as:</p>
<ul>
<li><strong>Using different criteria for different top-level crates.</strong> Your workspace
might contain both a production product and an internal tool, which might
require different levels of audits for their dependencies.</li>
</ul>
<p>If the default behavior works for you, there's no need to specify anything. If
you wish to encode policies such as the above, you can do so in
<a href="config.html#the-policy-table">config.toml</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-repositories"><a class="header" href="#multiple-repositories">Multiple Repositories</a></h1>
<p>The discussion thus far assumes the project exists in a single repository, but
it's common for organizations to manage code across multiple repositories. At
first glance this presents a dilemma as to whether to centralize or distribute
the audit records. Putting them all in one place makes them easier to consume,
but more cumbersome to produce, since updating a package in one repository may
require a developer to record a new audit in another repository.</p>
<p>The <code>cargo vet aggregate</code> subcommand resolves this tension. The command itself
simply takes a list of audit file URLs, and produces a single merged file<sup class="footnote-reference"><a href="#1">1</a></sup>.
The recommended workflow is as follows:</p>
<ol>
<li>Create a dedicated repository to host the merged audits.</li>
<li>Add a file called <code>sources.list</code> to this repository, which contains a plain
list of URLs for the audit files in each project.</li>
<li>Create a recurring task on that repository to invoke <code>cargo vet aggregate sources.list &gt; audits.toml</code> and commit the result if changed<sup class="footnote-reference"><a href="#2">2</a></sup>.</li>
<li>Add the aggregated audit file to the <code>imports</code> table of each individual
repository.</li>
</ol>
<p>Beyond streamlining the workflow within the project, this approach also makes it
easy for others to import the full audit set without needing to navigate the
details of various source repositories.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The entries in the new file have an additional <code>aggregated-from</code> field
which points to their original location.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>TODO: Example with GitHub Actions.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-ci"><a class="header" href="#configuring-ci">Configuring CI</a></h1>
<p>As a final step in setting up a project, it's strongly recommended to
<em>continuously</em> perform verification of your dependencies via your
project's continuous integration system.</p>
<p>An example of configuring this via GitHub Actions is to add this to your
configuration:</p>
<pre><code class="language-yml">name: CI
on: [push, pull_request]
jobs:
  cargo-vet:
    name: Vet Dependencies
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@master
    - name: Install Rust
      run: rustup update stable &amp;&amp; rustup default stable
    - run: cargo install cargo-vet
    - run: cargo vet --locked
</code></pre>
<p>This will ensure that that all changes made to your repository, either via a PR
or a direct push, have a fully-vetted dependency set.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This chapter of the book provides more detail and documentation about specific
aspects of <code>cargo vet</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>This section describes the structure and semantics of the various configuration
files used by <code>cargo vet</code>.</p>
<h2 id="location"><a class="header" href="#location">Location</a></h2>
<p>By default, <code>cargo vet</code> data lives in a <code>supply-chain</code> directory next to
<code>Cargo.lock</code>. This location is configurable via the <code>[package.metadata.vet]</code>
directive in Cargo.toml, as well as via <code>[workspace.metadata.vet]</code> when using a
workspace with a virtual root.</p>
<p>The default configuration is equivalent to the following:</p>
<pre><code class="language-toml">[package.metadata.vet]
store = { path = './supply-chain' }
</code></pre>
<h2 id="auditstoml-1"><a class="header" href="#auditstoml-1"><code>audits.toml</code></a></h2>
<p>This file contains the audits performed by the project members and descriptions
of the audit criteria. The information in this file can be imported by other
projects.</p>
<h3 id="the-criteria-table"><a class="header" href="#the-criteria-table">The <code>criteria</code> Table</a></h3>
<p>This table defines different sets of custom criteria. Entries have several
potential fields:</p>
<h4 id="description"><a class="header" href="#description"><code>description</code></a></h4>
<p>A concise description of the criteria. This field (or <code>description-url</code>) is
required.</p>
<h4 id="description-url"><a class="header" href="#description-url"><code>description-url</code></a></h4>
<p>An alternative to <code>description</code> which locates the criteria text at a
publicly-accessible URL. This can be useful for sharing criteria descriptions
across multiple repositories.</p>
<h4 id="implies"><a class="header" href="#implies"><code>implies</code></a></h4>
<p>An optional string or array of other criteria that are subsumed by this entry.
Audit entries that are certified with these criteria are also implicitly
certified with any implied criteria.</p>
<p>For example, specifying the <a href="built-in-criteria.html">built-in criteria</a> as custom
criteria would look like this:</p>
<pre><code>[criteria.safe-to-run]
description = '...'

[criteria.safe-to-deploy]
description = '...'
implies = 'safe-to-run'
</code></pre>
<h3 id="the-audits-table"><a class="header" href="#the-audits-table">The <code>audits</code> Table</a></h3>
<p>This table contains the audit entries, indexed by crate name. Because there are
often multiple audits per crate (different versions, delta audits, etc), audit
entries are specified as table arrays, i.e. <code>[[audits.foo]]</code>.</p>
<p>The semantics of the various audit entries keys are described
<a href="audit-entries.html">here</a>.</p>
<h2 id="configtoml"><a class="header" href="#configtoml"><code>config.toml</code></a></h2>
<p>This file contains configuration information for this specific project. This
file cannot be imported by other projects.</p>
<h3 id="default-criteria"><a class="header" href="#default-criteria"><code>default-criteria</code></a></h3>
<p>This top-level key specifies the default criteria that <code>cargo vet certify</code> will
use when recording audits. If unspecified, this defaults to <code>safe-to-deploy</code>.</p>
<h3 id="the-imports-table"><a class="header" href="#the-imports-table">The <code>imports</code> Table</a></h3>
<p>This table enumerates the external audit sets that are imported into this
project. The key is a user-defined nickname, so entries are specified as
<code>[imports.foo]</code>.</p>
<h4 id="url"><a class="header" href="#url"><code>url</code></a></h4>
<p>Specifies an HTTPS url from which the remote <code>audits.toml</code> can be fetched. This
field is required.</p>
<h4 id="criteria-map"><a class="header" href="#criteria-map"><code>criteria-map</code></a></h4>
<p>An inline table or array of inline tables specifying one or more mappings
between the audit criteria of the imported and local sets. Each imported audit
is matched against each mapping. If the imported audit certifies all of the
criteria listed in the <code>theirs</code> key, it is associated with the local criteria
specified in the <code>ours</code> key.</p>
<p>This will generally be a 1:1 mapping:</p>
<pre><code>criteria-map = { theirs: &quot;a&quot;, ours: &quot;x&quot; }
</code></pre>
<p>But can also be more complex:</p>
<pre><code>criteria-map = [ { theirs: &quot;b&quot;, ours: [&quot;y&quot;, &quot;z&quot;] },
                 { theirs: [&quot;c&quot;, &quot;d&quot;], ours: &quot;z&quot; } ]
</code></pre>
<h4 id="exclude"><a class="header" href="#exclude"><code>exclude</code></a></h4>
<p>A list of crates whose audit entries should not be imported from this source.
This can be used as a last resort to resolve disagreements over the suitability
of a given crate.</p>
<h3 id="the-policy-table"><a class="header" href="#the-policy-table">the <code>policy</code> Table</a></h3>
<p>This table maps first-party crates to the audit requirements that <code>cargo vet</code>
should enforce on their dependencies. When unspecified, non-top-level
first-party crates inherit policy attributes from their parents, whereas
top-level first-party crates get the defaults described below.</p>
<p>In this context, &quot;top-level&quot; generally refers to crates with no
reverse-dependencies — except when evaluating dev-dependencies, in which case
every workspace member is considered a root.</p>
<h4 id="criteria"><a class="header" href="#criteria"><code>criteria</code></a></h4>
<p>A string or array of strings specifying the criteria that should be enforced for
this crate and its dependency tree.</p>
<p>For top-level crates, defaults to <code>safe-to-deploy</code>.</p>
<h4 id="dev-criteria"><a class="header" href="#dev-criteria"><code>dev-criteria</code></a></h4>
<p>Same as the above, but applied to dev-dependencies.</p>
<p>For top-level crates, defaults to <code>safe-to-run</code>.</p>
<h4 id="dependency-criteria"><a class="header" href="#dependency-criteria"><code>dependency-criteria</code></a></h4>
<p>Allows overriding the above values on a per-dependency basis. Similar in format
to the <a href="audit-entries.html#dependency-criteria">equivalent field</a> in audit
entries.</p>
<p>Defaults to the empty set and is not inherited.</p>
<h4 id="notes"><a class="header" href="#notes"><code>notes</code></a></h4>
<p>Free-form string for recording rationale or other relevant information.</p>
<h3 id="the-unaudited-table"><a class="header" href="#the-unaudited-table">The <code>unaudited</code> Table</a></h3>
<p>This table enumerates the set of crates which are being used despite missing the
required audits. It has a similar structure to the <code>audits</code> table in
<code>audits.toml</code>, but each entry has fewer supported fields.</p>
<h4 id="version"><a class="header" href="#version"><code>version</code></a></h4>
<p>Specifies the exact version which should be exempted.</p>
<h4 id="criteria-1"><a class="header" href="#criteria-1"><code>criteria</code></a></h4>
<p>Specifies the criteria covered by the exemption.</p>
<h4 id="notes-1"><a class="header" href="#notes-1"><code>notes</code></a></h4>
<p>Free-form string for recording rationale or other relevant information.</p>
<h4 id="suggest"><a class="header" href="#suggest"><code>suggest</code></a></h4>
<p>A boolean indicating whether this entry is eligible to be surfaced by <code>cargo vet suggest</code>.</p>
<p>Defaults to true. This exists to allow you silence certain suggestions that, for
whatever reason, you don't plan to act on in the immediate future.</p>
<h2 id="importslock"><a class="header" href="#importslock"><code>imports.lock</code></a></h2>
<p>This file is auto-generated by <code>cargo vet</code> and its format should be treated as
an implementation detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audit-entries"><a class="header" href="#audit-entries">Audit Entries</a></h1>
<p>This section defines the semantics of the various keys that may be specified in
audit table entries.</p>
<h2 id="version-1"><a class="header" href="#version-1"><code>version</code></a></h2>
<p>Specifies that this audit entry corresponds to an absolute version that was
audited for the relevant criteria in its entirety.</p>
<h2 id="delta"><a class="header" href="#delta"><code>delta</code></a></h2>
<p>Specifies that this audit entry certifies that the delta between two absolute
versions preserves the relevant criteria. Deltas can go both forward and
backward in the version sequence.</p>
<p>The syntax is <code>version_a -&gt; version_b</code>, where the diff between version_a and
version_b was audited.</p>
<p>Note that it's not always possible to conclude that a diff preserves certain
properties without also inspecting some portion of the base version. The
standard here is that the properties are actually preserved, not merely that
that the diff doesn't obviously violate them. It is the responsibility of the
auditor to acquire sufficient context to certify the former.</p>
<h2 id="violation"><a class="header" href="#violation"><code>violation</code></a></h2>
<p>Specifies that the given versions do not meet the associated criteria. Because a
range of versions is usually required, this field uses Cargo's standard
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">VersionReq</a>
syntax.</p>
<p>If a <code>violation</code> entry exists for a given crate version, <code>cargo vet</code> will reject
the dependency even if it's listed in the <code>unaudited</code> table.</p>
<h2 id="criteria-2"><a class="header" href="#criteria-2"><code>criteria</code></a></h2>
<p>Specifies the relevant criteria for this audit. This field is required.</p>
<h2 id="who"><a class="header" href="#who"><code>who</code></a></h2>
<p>A string identifying the auditor. When invoking <code>cargo vet certify</code>, the
value is auto-populated from the git config.</p>
<p>This field is optional, but encouraged for two reasons:</p>
<ul>
<li>It makes it easier to attribute audits at a glance, particularly for
remotely-hosted audit files.</li>
<li>It emphasizes to the author that they are signing off on having performed the
audit.</li>
</ul>
<h2 id="notes-2"><a class="header" href="#notes-2"><code>notes</code></a></h2>
<p>An optional free-form string containing any information the auditor may wish to
record.</p>
<h2 id="dependency-criteria-1"><a class="header" href="#dependency-criteria-1"><code>dependency-criteria</code></a></h2>
<p>An optional inline table specifying the criteria the vetting algorithm should
check for in a dependency subtree.</p>
<p>Ordinarily, when vetting a crate for criteria <code>foo</code>, <code>cargo vet</code> will
recursively vet each direct dependency for <code>foo</code> as well. This is usually what
you want, but occasionally you may wish to add or remove criteria for certain
subtrees.</p>
<p>For example, a dependency used to encrypt sensitive data might need review from
cryptography experts:</p>
<pre><code>[audit.mynetworkingcrate]
version = '2.3.4'
dependency_criteria = { hmac: ['safe-to-deploy', 'crypto-reviewed'] }
</code></pre>
<p>Alternatively, a dependency might be used in a very limited way that allows you
to reduce the level of scrutiny. For example, a crate might import a sprawling
platform binding crate just to invoke one or two native functions:</p>
<pre><code>[audit.foo]
version = '1.5.2'
dependency-criteria = { winapi: 'safe-to-run' }
notes = '''
  The winapi dependency is only used in a few places, and I have directly audited
  the parts of it that are used. As long as we ensure that minor updates don't
  include blatantly malicious code in the build script we should be fine.
  '''

</code></pre>
<p>This field only has an effect when the associated audit entry is actually used
in the recursive vetting algorithm. In the case where multiple entries are used
for a single crate, their <code>dependency-criteria</code> are unioned together.</p>
<p>These criteria propagate through the entire subtree unless inner branches
specify their own <code>dependency-criteria</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-criteria"><a class="header" href="#built-in-criteria">Built-In Criteria</a></h1>
<p>While you can define whatever criteria you like, <code>cargo vet</code> includes two
commonly-used audit criteria out of the box. These criteria are automatically
mapped across projects.</p>
<h2 id="safe-to-run"><a class="header" href="#safe-to-run">safe-to-run</a></h2>
<pre><code>This crate can be compiled, run, and tested on a local workstation or in
controlled automation without surprising consequences, such as:
* Reading or writing data from sensitive or unrelated parts of the filesystem.
* Installing software or reconfiguring the device.
* Connecting to untrusted network endpoints.
* Misuse of system resources (e.g. cryptocurrency mining).
</code></pre>
<h2 id="safe-to-deploy"><a class="header" href="#safe-to-deploy">safe-to-deploy</a></h2>
<pre><code>This crate will not introduce a serious security vulnerability to production
software exposed to untrusted input.

Auditors are not required to perform a full logic review of the entire crate.
Rather, they must review enough to fully reason about the behavior of all unsafe
blocks and usage of powerful imports. For any reasonable usage of the crate in
real-world software, an attacker must not be able to manipulate the runtime
behavior of these sections in an exploitable or surprising way.

Ideally, all unsafe code is fully sound, and ambient capabilities (e.g.
filesystem access) are hardened against manipulation and consistent with the
advertised behavior of the crate. However, some discretion is permitted. In such
cases, the nature of the discretion should be recorded in the `notes` field of
the audit record.

For crates which generate deployed code (e.g. build dependencies or procedural
macros), reasonable usage of the crate should output code which meets the above
criteria.
</code></pre>
<p>This implies <code>safe-to-run</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>This section documents the command-line interface of <code>cargo vet</code>. The
documentation is automatically generated from the implementation, and
so it may be incomplete in some areas where the code remains under
development.</p>
<p>When run without a subcommand, <code>cargo vet</code> will invoke the <code>check</code> subcommand. See <code>cargo vet help check</code> for more details.</p>
<h3 id="usage"><a class="header" href="#usage">USAGE</a></h3>
<pre><code>cargo vet [OPTIONS]
</code></pre>
<pre><code>cargo vet &lt;SUBCOMMAND&gt;
</code></pre>
<h3 id="options"><a class="header" href="#options">OPTIONS</a></h3>
<h4 id="--shallow"><a class="header" href="#--shallow"><code>--shallow</code></a></h4>
<p>Avoid suggesting audits for dependencies of unaudited dependencies.</p>
<p>By default, if a dependency doesn't have sufficient audits for <em>itself</em> then we try to
speculate that its dependencies require the criteria. This flag disables that behaviour,
causing only suggestions which we're certain of the requirements for to be emitted.</p>
<h4 id="-h---help"><a class="header" href="#-h---help"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h4 id="-v---version"><a class="header" href="#-v---version"><code>-V, --version</code></a></h4>
<p>Print version information</p>
<h3 id="global-options"><a class="header" href="#global-options">GLOBAL OPTIONS</a></h3>
<h4 id="--manifest-path-path"><a class="header" href="#--manifest-path-path"><code>--manifest-path &lt;PATH&gt;</code></a></h4>
<p>Path to Cargo.toml</p>
<h4 id="--no-all-features"><a class="header" href="#--no-all-features"><code>--no-all-features</code></a></h4>
<p>Don't use --all-features</p>
<p>We default to passing --all-features to <code>cargo metadata</code> because we want to analyze your
full dependency tree</p>
<h4 id="--no-default-features"><a class="header" href="#--no-default-features"><code>--no-default-features</code></a></h4>
<p>Do not activate the <code>default</code> feature</p>
<h4 id="--features-features"><a class="header" href="#--features-features"><code>--features &lt;FEATURES&gt;</code></a></h4>
<p>Space-separated list of features to activate</p>
<h4 id="--locked"><a class="header" href="#--locked"><code>--locked</code></a></h4>
<p>Do not fetch new imported audits</p>
<h4 id="--frozen"><a class="header" href="#--frozen"><code>--frozen</code></a></h4>
<p>Avoid the network entirely, requiring either that the cargo cache is populated or the
dependencies are vendored. Requires --locked</p>
<h4 id="--verbose-verbose"><a class="header" href="#--verbose-verbose"><code>--verbose &lt;VERBOSE&gt;</code></a></h4>
<p>How verbose logging should be (log level)</p>
<p>[default: warn]<br />
[possible values: off, error, warn, info, debug, trace]</p>
<h4 id="--output-file-output_file"><a class="header" href="#--output-file-output_file"><code>--output-file &lt;OUTPUT_FILE&gt;</code></a></h4>
<p>Instead of stdout, write output to this file</p>
<h4 id="--log-file-log_file"><a class="header" href="#--log-file-log_file"><code>--log-file &lt;LOG_FILE&gt;</code></a></h4>
<p>Instead of stderr, write logs to this file (only used after successful CLI parsing)</p>
<h4 id="--output-format-output_format"><a class="header" href="#--output-format-output_format"><code>--output-format &lt;OUTPUT_FORMAT&gt;</code></a></h4>
<p>The format of the output</p>
<p>[default: human]<br />
[possible values: human, json]</p>
<h4 id="--diff-cache-diff_cache"><a class="header" href="#--diff-cache-diff_cache"><code>--diff-cache &lt;DIFF_CACHE&gt;</code></a></h4>
<p>Use the following path as the diff-cache</p>
<p>The diff-cache stores the summary results used by vet's suggestion machinery. This is
automatically managed in vet's tempdir, but if you want to manually store it somewhere
more reliable, you can.</p>
<p>This mostly exists for testing vet itself.</p>
<h4 id="--filter-graph-filter_graph"><a class="header" href="#--filter-graph-filter_graph"><code>--filter-graph &lt;FILTER_GRAPH&gt;</code></a></h4>
<p>Filter out different parts of the build graph and pretend that's the true graph</p>
<p>Example: <code>--filter-graph=&quot;exclude(any(eq(is_dev_only(true)),eq(name(serde_derive))))&quot;</code></p>
<p>This mostly exists to debug or reduce projects that cargo-vet is mishandling.
Combining this with <code>cargo vet --output-format=json dump-graph</code> can produce an
input that can be added to vet's test suite.</p>
<p>The resulting graph is computed as follows:</p>
<ol>
<li>First compute the original graph</li>
<li>Then apply the filters to find the new set of nodes</li>
<li>Create a new empty graph</li>
<li>For each workspace member that still exists, recursively add it and its dependencies</li>
</ol>
<p>This means that any non-workspace package that becomes &quot;orphaned&quot; by the filters will
be implicitly discarded even if it passes the filters.</p>
<p>Possible filters:</p>
<ul>
<li><code>include($query)</code>: only include packages that match this filter</li>
<li><code>exclude($query)</code>: exclude packages that match this filter</li>
</ul>
<p>Possible queries:</p>
<ul>
<li><code>any($query1, $query2, ...)</code>: true if any of the listed queries are true</li>
<li><code>all($query1, $query2, ...)</code>: true if all of the listed queries are true</li>
<li><code>not($query)</code>: true if the query is false</li>
<li><code>$property</code>: true if the package has this property</li>
</ul>
<p>Possible properties:</p>
<ul>
<li><code>name($string)</code>: the package's name (i.e. <code>serde</code>)</li>
<li><code>version($version)</code>: the package's version (i.e. <code>1.2.0</code>)</li>
<li><code>is_root($bool)</code>: whether it's a root in the original graph (ignoring dev-deps)</li>
<li><code>is_workspace_member($bool)</code>: whether the package is a workspace-member (can be
tested)</li>
<li><code>is_third_party($bool)</code>: whether the package is considered third-party by vet</li>
<li><code>is_dev_only($bool)</code>: whether it's only used by dev (test) builds in the original
graph</li>
</ul>
<h3 id="subcommands"><a class="header" href="#subcommands">SUBCOMMANDS</a></h3>
<ul>
<li><a href="commands.html#cargo-vet-check">check</a>: [default] Check that the current project has been vetted</li>
<li><a href="commands.html#cargo-vet-suggest">suggest</a>: Suggest some low-hanging fruit to review</li>
<li><a href="commands.html#cargo-vet-init">init</a>: Initialize cargo-vet for your project</li>
<li><a href="commands.html#cargo-vet-inspect">inspect</a>: Fetch the source of a package</li>
<li><a href="commands.html#cargo-vet-diff">diff</a>: Yield a diff against the last reviewed version</li>
<li><a href="commands.html#cargo-vet-certify">certify</a>: Mark a package as audited</li>
<li><a href="commands.html#cargo-vet-regenerate">regenerate</a>: Explicitly regenerate various pieces of information</li>
<li><a href="commands.html#cargo-vet-add-exemption">add-exemption</a>: Mark a package as exempted from review</li>
<li><a href="commands.html#cargo-vet-record-violation">record-violation</a>: Declare that some versions of a package violate certain audit criteria</li>
<li><a href="commands.html#cargo-vet-fmt">fmt</a>: Reformat all of vet's files (in case you hand-edited them)</li>
<li><a href="commands.html#cargo-vet-fetch-imports">fetch-imports</a>: Explicitly fetch the imports (foreign audit files)</li>
<li><a href="commands.html#cargo-vet-dump-graph">dump-graph</a>: Print the cargo build graph as understood by <code>cargo vet</code></li>
<li><a href="commands.html#cargo-vet-gc">gc</a>: Clean up old packages from the vet cache</li>
<li><a href="commands.html#cargo-vet-help">help</a>: Print this message or the help of the given subcommand(s)</li>
</ul>
<p><br><br><br></p>
<h2 id="cargo-vet-check"><a class="header" href="#cargo-vet-check">cargo vet check</a></h2>
<p>[default] Check that the current project has been vetted</p>
<p>This is the default behaviour if no subcommand is specified.</p>
<p>If the check fails due to lack of audits, we will do our best to explain why vetting failed, and
what should be done to fix it. This can involve a certain amount of guesswork, as there are many
possible solutions and we only want to recommend the &quot;best&quot; one to keep things simple.</p>
<p>Failures and suggestions can either be &quot;Certain&quot; or &quot;Speculative&quot;. Speculative items are greyed
out and sorted lower to indicate that the Certain entries should be looked at first. Speculative
items are for packages that probably need audits too, but only appear as transitive dependencies of
Certain items.</p>
<p>During review of Certain issues you may take various actions that change what's needed for the
Speculative ones. For instance you may discover you're enabling a feature you don't need, and
that's the only reason the Speculative package is in your tree. Or you may determine that the
Certain package only needs to be safe-to-run, which may make the Speculative requirements weaker or
completely resolved. For these reasons we recommend fixing problems &quot;top down&quot;, and Certain items
are The Top.</p>
<p>Suggested fixes are grouped by the criteria they should be reviewed for and sorted by how easy the
review should be (in terms of lines of code). We only ever suggest audits (and provide the command
you need to run to do it), but there are other possible fixes like an <code>exemption</code> or <code>policy</code>
change.</p>
<p>The most aggressive solution is to run <code>cargo vet regenerate exemptions</code> which will add whatever
exemptions necessary to make <code>check</code> pass (and remove uneeded ones). Ideally you should avoid doing
this and prefer adding audits, but if you've done all the audits you plan on doing, that's the way
to finish the job.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">USAGE</a></h3>
<pre><code>cargo vet check [OPTIONS]
</code></pre>
<h3 id="options-1"><a class="header" href="#options-1">OPTIONS</a></h3>
<h4 id="--shallow-1"><a class="header" href="#--shallow-1"><code>--shallow</code></a></h4>
<p>Avoid suggesting audits for dependencies of unaudited dependencies.</p>
<p>By default, if a dependency doesn't have sufficient audits for <em>itself</em> then we try to
speculate that its dependencies require the criteria. This flag disables that behaviour,
causing only suggestions which we're certain of the requirements for to be emitted.</p>
<h4 id="-h---help-1"><a class="header" href="#-h---help-1"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-1"><a class="header" href="#global-options-1">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-suggest"><a class="header" href="#cargo-vet-suggest">cargo vet suggest</a></h2>
<p>Suggest some low-hanging fruit to review</p>
<p>This is essentially the same as <code>check</code> but with all your <code>exemptions</code> temporarily removed as a way
to inspect your &quot;review backlog&quot;. As such, we recommend against running this command while <code>check</code>
is failing, because this will just give you worse information.</p>
<p>If you don't consider an exemption to be &quot;backlog&quot;, add <code>suggest = false</code> to its entry and we won't
remove it while suggesting.</p>
<p>See also <code>regenerate exemptions</code>, which can be used to &quot;garbage collect&quot; your backlog (if you run it
while <code>check</code> is passing).</p>
<h3 id="usage-2"><a class="header" href="#usage-2">USAGE</a></h3>
<pre><code>cargo vet suggest [OPTIONS]
</code></pre>
<h3 id="options-2"><a class="header" href="#options-2">OPTIONS</a></h3>
<h4 id="--shallow-2"><a class="header" href="#--shallow-2"><code>--shallow</code></a></h4>
<p>Avoid suggesting audits for dependencies of unaudited dependencies.</p>
<p>By default, if a dependency doesn't have sufficient audits for <em>itself</em> then we try to
speculate that its dependencies require the criteria. This flag disables that behaviour,
causing only suggestions which we're certain of the requirements for to be emitted.</p>
<h4 id="-h---help-2"><a class="header" href="#-h---help-2"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-2"><a class="header" href="#global-options-2">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-init"><a class="header" href="#cargo-vet-init">cargo vet init</a></h2>
<p>Initialize cargo-vet for your project</p>
<p>This will add <code>exemptions</code> and <code>audit-as-crates-io = false</code> for all packages that need it to make
<code>check</code> pass immediately and make it easy to start using vet with your project.</p>
<p>At this point you can either configure your project further or start working on your review backlog
with <code>suggest</code>.</p>
<h3 id="usage-3"><a class="header" href="#usage-3">USAGE</a></h3>
<pre><code>cargo vet init [OPTIONS]
</code></pre>
<h3 id="options-3"><a class="header" href="#options-3">OPTIONS</a></h3>
<h4 id="-h---help-3"><a class="header" href="#-h---help-3"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-3"><a class="header" href="#global-options-3">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-inspect"><a class="header" href="#cargo-vet-inspect">cargo vet inspect</a></h2>
<p>Fetch the source of a package</p>
<p>We will attempt to guess what criteria you want to audit the package for based on the current check/
suggest status, and show you the meaning of those criteria ahead of time.</p>
<h3 id="usage-4"><a class="header" href="#usage-4">USAGE</a></h3>
<pre><code>cargo vet inspect [OPTIONS] &lt;PACKAGE&gt; &lt;VERSION&gt;
</code></pre>
<h3 id="args"><a class="header" href="#args">ARGS</a></h3>
<h4 id="package"><a class="header" href="#package"><code>&lt;PACKAGE&gt;</code></a></h4>
<p>The package to inspect</p>
<h4 id="version-2"><a class="header" href="#version-2"><code>&lt;VERSION&gt;</code></a></h4>
<p>The version to inspect</p>
<h3 id="options-4"><a class="header" href="#options-4">OPTIONS</a></h3>
<h4 id="--mode-mode"><a class="header" href="#--mode-mode"><code>--mode &lt;MODE&gt;</code></a></h4>
<p>How to inspect the source</p>
<p>[default: sourcegraph]<br />
[possible values: local, sourcegraph]</p>
<h4 id="-h---help-4"><a class="header" href="#-h---help-4"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-4"><a class="header" href="#global-options-4">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-diff"><a class="header" href="#cargo-vet-diff">cargo vet diff</a></h2>
<p>Yield a diff against the last reviewed version</p>
<p>We will attempt to guess what criteria you want to audit the package for based on the current check/
suggest status, and show you the meaning of those criteria ahead of time.</p>
<h3 id="usage-5"><a class="header" href="#usage-5">USAGE</a></h3>
<pre><code>cargo vet diff [OPTIONS] &lt;PACKAGE&gt; &lt;VERSION1&gt; &lt;VERSION2&gt;
</code></pre>
<h3 id="args-1"><a class="header" href="#args-1">ARGS</a></h3>
<h4 id="package-1"><a class="header" href="#package-1"><code>&lt;PACKAGE&gt;</code></a></h4>
<p>The package to diff</p>
<h4 id="version1"><a class="header" href="#version1"><code>&lt;VERSION1&gt;</code></a></h4>
<p>The base version to diff</p>
<h4 id="version2"><a class="header" href="#version2"><code>&lt;VERSION2&gt;</code></a></h4>
<p>The target version to diff</p>
<h3 id="options-5"><a class="header" href="#options-5">OPTIONS</a></h3>
<h4 id="--mode-mode-1"><a class="header" href="#--mode-mode-1"><code>--mode &lt;MODE&gt;</code></a></h4>
<p>How to inspect the source</p>
<p>[default: sourcegraph]<br />
[possible values: local, sourcegraph]</p>
<h4 id="-h---help-5"><a class="header" href="#-h---help-5"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-5"><a class="header" href="#global-options-5">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-certify"><a class="header" href="#cargo-vet-certify">cargo vet certify</a></h2>
<p>Mark a package as audited</p>
<p>This command will do its best to guess what you want to be certifying.</p>
<p>If invoked with no args, it will try to certify the last thing you looked at with <code>inspect</code> or
<code>diff</code>. Otherwise you must either supply the package name and one version (for a full audit) or two
versions (for a delta audit).</p>
<p>Once the package+version(s) have been selected, we will try to guess what criteria to certify it
for. First we will <code>check</code>, and if the check fails and your audit would seemingly fix this package,
we will use the criteria recommended for that fix. If <code>check</code> passes, we will assume you are working
on your backlog and instead use the recommendations of <code>suggest</code>.</p>
<p>If this removes the need for an <code>exemption</code> will we automatically remove it.</p>
<h3 id="usage-6"><a class="header" href="#usage-6">USAGE</a></h3>
<pre><code>cargo vet certify [OPTIONS] [ARGS]
</code></pre>
<h3 id="args-2"><a class="header" href="#args-2">ARGS</a></h3>
<h4 id="package-2"><a class="header" href="#package-2"><code>&lt;PACKAGE&gt;</code></a></h4>
<p>The package to certify as audited</p>
<h4 id="version1-1"><a class="header" href="#version1-1"><code>&lt;VERSION1&gt;</code></a></h4>
<p>The version to certify as audited</p>
<h4 id="version2-1"><a class="header" href="#version2-1"><code>&lt;VERSION2&gt;</code></a></h4>
<p>If present, instead certify a diff from version1-&gt;version2</p>
<h3 id="options-6"><a class="header" href="#options-6">OPTIONS</a></h3>
<h4 id="--criteria-criteria"><a class="header" href="#--criteria-criteria"><code>--criteria &lt;CRITERIA&gt;</code></a></h4>
<p>The criteria to certify for this audit</p>
<p>If not provided, we will prompt you for this information.</p>
<h4 id="--dependency-criteria-dependency_criteria"><a class="header" href="#--dependency-criteria-dependency_criteria"><code>--dependency-criteria &lt;DEPENDENCY_CRITERIA&gt;</code></a></h4>
<p>The dependency-criteria to require for this audit to be valid</p>
<p>If not provided, we will still implicitly require dependencies to satisfy <code>criteria</code>.</p>
<h4 id="--who-who"><a class="header" href="#--who-who"><code>--who &lt;WHO&gt;</code></a></h4>
<p>Who to name as the auditor</p>
<p>If not provided, we will collect this information from the local git.</p>
<h4 id="--notes-notes"><a class="header" href="#--notes-notes"><code>--notes &lt;NOTES&gt;</code></a></h4>
<p>A free-form string to include with the new audit entry</p>
<p>If not provided, there will be no notes.</p>
<h4 id="--accept-all"><a class="header" href="#--accept-all"><code>--accept-all</code></a></h4>
<p>Accept all criteria without an interactive prompt</p>
<h4 id="--force"><a class="header" href="#--force"><code>--force</code></a></h4>
<p>Force the command to ignore whether the package/version makes sense</p>
<p>To catch typos/mistakes, we check if the thing you're trying to talk about is part of
your current build, but this flag disables that.</p>
<h4 id="-h---help-6"><a class="header" href="#-h---help-6"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-6"><a class="header" href="#global-options-6">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-regenerate"><a class="header" href="#cargo-vet-regenerate">cargo vet regenerate</a></h2>
<p>Explicitly regenerate various pieces of information</p>
<p>There are several things that <code>cargo vet</code> <em>can</em> do for you automatically but we choose to make
manual just to keep a human in the loop of those decisions. Some of these might one day become
automatic if we agree they're boring/reliable enough.</p>
<p>See the subcommands for specifics.</p>
<h3 id="usage-7"><a class="header" href="#usage-7">USAGE</a></h3>
<pre><code>cargo vet regenerate [OPTIONS] &lt;SUBCOMMAND&gt;
</code></pre>
<h3 id="options-7"><a class="header" href="#options-7">OPTIONS</a></h3>
<h4 id="-h---help-7"><a class="header" href="#-h---help-7"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-7"><a class="header" href="#global-options-7">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<h3 id="subcommands-1"><a class="header" href="#subcommands-1">SUBCOMMANDS</a></h3>
<ul>
<li><a href="commands.html#cargo-vet-exemptions">exemptions</a>: Regenerate your exemptions to make <code>check</code> pass minimally</li>
<li><a href="commands.html#cargo-vet-imports">imports</a>: Regenerate your imports and accept changes to criteria</li>
<li><a href="commands.html#cargo-vet-audit-as-crates-io">audit-as-crates-io</a>: Regenerate you audit-as-crates-io entries to make <code>check</code> pass</li>
<li><a href="commands.html#cargo-vet-help">help</a>: Print this message or the help of the given subcommand(s)</li>
</ul>
<p><br><br><br></p>
<h2 id="cargo-vet-exemptions"><a class="header" href="#cargo-vet-exemptions">cargo vet exemptions</a></h2>
<p>Regenerate your exemptions to make <code>check</code> pass minimally</p>
<p>This command can be used for two purposes: to force your supply-chain to pass <code>check</code> when it's
currently failing, or to minimize/garbage-collect your exemptions when it's already passing. These
are ultimately the same operation.</p>
<p>We will try our best to preserve existing exemptions, removing only those that aren't needed,
and adding only those that are needed. Exemptions that are overbroad may also be weakened (i.e.
safe-to-deploy may be reduced to safe-to-run).</p>
<h3 id="usage-8"><a class="header" href="#usage-8">USAGE</a></h3>
<pre><code>cargo vet regenerate exemptions [OPTIONS]
</code></pre>
<h3 id="options-8"><a class="header" href="#options-8">OPTIONS</a></h3>
<h4 id="-h---help-8"><a class="header" href="#-h---help-8"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-8"><a class="header" href="#global-options-8">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-imports"><a class="header" href="#cargo-vet-imports">cargo vet imports</a></h2>
<p>Regenerate your imports and accept changes to criteria</p>
<p>This is equivalent to <code>cargo vet fetch-imports</code> but it won't produce an error if the descriptions of
foreign criteria change.</p>
<h3 id="usage-9"><a class="header" href="#usage-9">USAGE</a></h3>
<pre><code>cargo vet regenerate imports [OPTIONS]
</code></pre>
<h3 id="options-9"><a class="header" href="#options-9">OPTIONS</a></h3>
<h4 id="-h---help-9"><a class="header" href="#-h---help-9"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-9"><a class="header" href="#global-options-9">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-audit-as-crates-io"><a class="header" href="#cargo-vet-audit-as-crates-io">cargo vet audit-as-crates-io</a></h2>
<p>Regenerate you audit-as-crates-io entries to make <code>check</code> pass</p>
<p>This will just set any problematic entries to <code>audit-as-crates-io = false</code>.</p>
<h3 id="usage-10"><a class="header" href="#usage-10">USAGE</a></h3>
<pre><code>cargo vet regenerate audit-as-crates-io [OPTIONS]
</code></pre>
<h3 id="options-10"><a class="header" href="#options-10">OPTIONS</a></h3>
<h4 id="-h---help-10"><a class="header" href="#-h---help-10"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-10"><a class="header" href="#global-options-10">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-help"><a class="header" href="#cargo-vet-help">cargo vet help</a></h2>
<p>Print this message or the help of the given subcommand(s)</p>
<h3 id="usage-11"><a class="header" href="#usage-11">USAGE</a></h3>
<pre><code>cargo vet regenerate help [OPTIONS] [SUBCOMMAND]...
</code></pre>
<h3 id="args-3"><a class="header" href="#args-3">ARGS</a></h3>
<h4 id="subcommand"><a class="header" href="#subcommand"><code>&lt;SUBCOMMAND&gt;...</code></a></h4>
<p>The subcommand whose help message to display</p>
<h3 id="global-options-11"><a class="header" href="#global-options-11">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-add-exemption"><a class="header" href="#cargo-vet-add-exemption">cargo vet add-exemption</a></h2>
<p>Mark a package as exempted from review</p>
<p>Exemptions are <em>usually</em> just &quot;backlog&quot; and the expectation is that you will review them
&quot;eventually&quot;. You should usually only be trying to remove them, but sometimes additions are
necessary to make progress.</p>
<p><code>regenerate exemptions</code> will do this for your automatically to make <code>check</code> pass (and remove any
unnecessary ones), so we recommend using that over <code>add-exemption</code>. This command mostly exists as
&quot;plumbing&quot; for building tools on top of <code>cargo vet</code>.</p>
<h3 id="usage-12"><a class="header" href="#usage-12">USAGE</a></h3>
<pre><code>cargo vet add-exemption [OPTIONS] &lt;PACKAGE&gt; &lt;VERSION&gt;
</code></pre>
<h3 id="args-4"><a class="header" href="#args-4">ARGS</a></h3>
<h4 id="package-3"><a class="header" href="#package-3"><code>&lt;PACKAGE&gt;</code></a></h4>
<p>The package to mark as exempted</p>
<h4 id="version-3"><a class="header" href="#version-3"><code>&lt;VERSION&gt;</code></a></h4>
<p>The version to mark as exempted</p>
<h3 id="options-11"><a class="header" href="#options-11">OPTIONS</a></h3>
<h4 id="--criteria-criteria-1"><a class="header" href="#--criteria-criteria-1"><code>--criteria &lt;CRITERIA&gt;</code></a></h4>
<p>The criteria to assume (trust)</p>
<p>If not provided, we will prompt you for this information.</p>
<h4 id="--dependency-criteria-dependency_criteria-1"><a class="header" href="#--dependency-criteria-dependency_criteria-1"><code>--dependency-criteria &lt;DEPENDENCY_CRITERIA&gt;</code></a></h4>
<p>The dependency-criteria to require for this exemption to be valid</p>
<p>If not provided, we will still implicitly require dependencies to satisfy <code>criteria</code>.</p>
<h4 id="--notes-notes-1"><a class="header" href="#--notes-notes-1"><code>--notes &lt;NOTES&gt;</code></a></h4>
<p>A free-form string to include with the new forbid entry</p>
<p>If not provided, there will be no notes.</p>
<h4 id="--no-suggest"><a class="header" href="#--no-suggest"><code>--no-suggest</code></a></h4>
<p>Suppress suggesting this exemption for review</p>
<h4 id="--force-1"><a class="header" href="#--force-1"><code>--force</code></a></h4>
<p>Force the command to ignore whether the package/version makes sense</p>
<p>To catch typos/mistakes, we check if the thing you're trying to talk about is part of
your current build, but this flag disables that.</p>
<h4 id="-h---help-11"><a class="header" href="#-h---help-11"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-12"><a class="header" href="#global-options-12">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-record-violation"><a class="header" href="#cargo-vet-record-violation">cargo vet record-violation</a></h2>
<p>Declare that some versions of a package violate certain audit criteria</p>
<p><strong>IMPORTANT</strong>: violations take <em>VersionReqs</em> not <em>Versions</em>. This is the same syntax used by
Cargo.toml when specifying dependencies. A bare <code>1.0.0</code> actually means <code>^1.0.0</code>. If you want to
forbid a <em>specific</em> version, use <code>=1.0.0</code>. This command can be a bit awkward because syntax like <code>*</code>
has special meaning in scripts and terminals. It's probably easier to just manually add the entry to
your audits.toml, but the command's here in case you want it.</p>
<p>Violations are essentially treated as integrity constraints on your supply-chain, and will only
result in errors if you have <code>exemptions</code> or <code>audits</code> (including imported ones) that claim criteria
that are contradicted by the <code>violation</code>. It is not inherently an error to depend on a package with
a <code>violation</code>.</p>
<p>For instance, someone may review a package and determine that it's horribly unsound in the face of
untrusted inputs, and therefore <em>un</em>safe-to-deploy. They would then add a &quot;safe-to-deploy&quot; violation
for whatever versions of that package seem to have that problem. But if the package basically works
fine on trusted inputs, it might still be safe-to-run. So if you use it in your tests and have an
audit that only claims safe-to-run, we won't mention it.</p>
<p>When a violation <em>does</em> cause an integrity error, it's up to you and your peers to figure out what
to do about it. There isn't yet a mechanism for dealing with disagreements with a peer's published
violations.</p>
<h3 id="usage-13"><a class="header" href="#usage-13">USAGE</a></h3>
<pre><code>cargo vet record-violation [OPTIONS] &lt;PACKAGE&gt; &lt;VERSIONS&gt;
</code></pre>
<h3 id="args-5"><a class="header" href="#args-5">ARGS</a></h3>
<h4 id="package-4"><a class="header" href="#package-4"><code>&lt;PACKAGE&gt;</code></a></h4>
<p>The package to forbid</p>
<h4 id="versions"><a class="header" href="#versions"><code>&lt;VERSIONS&gt;</code></a></h4>
<p>The versions to forbid</p>
<h3 id="options-12"><a class="header" href="#options-12">OPTIONS</a></h3>
<h4 id="--criteria-criteria-2"><a class="header" href="#--criteria-criteria-2"><code>--criteria &lt;CRITERIA&gt;</code></a></h4>
<p>The criteria that have failed to be satisfied.</p>
<p>If not provided, we will prompt you for this information(?)</p>
<h4 id="--who-who-1"><a class="header" href="#--who-who-1"><code>--who &lt;WHO&gt;</code></a></h4>
<p>Who to name as the auditor</p>
<p>If not provided, we will collect this information from the local git.</p>
<h4 id="--notes-notes-2"><a class="header" href="#--notes-notes-2"><code>--notes &lt;NOTES&gt;</code></a></h4>
<p>A free-form string to include with the new forbid entry</p>
<p>If not provided, there will be no notes.</p>
<h4 id="--force-2"><a class="header" href="#--force-2"><code>--force</code></a></h4>
<p>Force the command to ignore whether the package/version makes sense</p>
<p>To catch typos/mistakes, we check if the thing you're trying to talk about is part of
your current build, but this flag disables that.</p>
<h4 id="-h---help-12"><a class="header" href="#-h---help-12"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-13"><a class="header" href="#global-options-13">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-fmt"><a class="header" href="#cargo-vet-fmt">cargo vet fmt</a></h2>
<p>Reformat all of vet's files (in case you hand-edited them)</p>
<p>Most commands will implicitly do this, so this mostly exists as &quot;plumbing&quot; for building tools on top
of vet, or in case you don't want to run another command.</p>
<h3 id="usage-14"><a class="header" href="#usage-14">USAGE</a></h3>
<pre><code>cargo vet fmt [OPTIONS]
</code></pre>
<h3 id="options-13"><a class="header" href="#options-13">OPTIONS</a></h3>
<h4 id="-h---help-13"><a class="header" href="#-h---help-13"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-14"><a class="header" href="#global-options-14">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-fetch-imports"><a class="header" href="#cargo-vet-fetch-imports">cargo vet fetch-imports</a></h2>
<p>Explicitly fetch the imports (foreign audit files)</p>
<p><code>cargo vet check</code> will implicitly do this, so this mostly exists as &quot;plumbing&quot; for building tools on
top of vet.</p>
<h3 id="usage-15"><a class="header" href="#usage-15">USAGE</a></h3>
<pre><code>cargo vet fetch-imports [OPTIONS]
</code></pre>
<h3 id="options-14"><a class="header" href="#options-14">OPTIONS</a></h3>
<h4 id="-h---help-14"><a class="header" href="#-h---help-14"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-15"><a class="header" href="#global-options-15">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-dump-graph"><a class="header" href="#cargo-vet-dump-graph">cargo vet dump-graph</a></h2>
<p>Print the cargo build graph as understood by <code>cargo vet</code></p>
<p>This is a debugging command, the output's format is not guaranteed. Use <code>cargo metadata</code> to get a
stable version of what <em>cargo</em> thinks the build graph is. Our graph is based on that result.</p>
<p>With <code>--output-format=human</code> (the default) this will print out mermaid-js diagrams, which things
like github natively support rendering of.</p>
<p>With <code>--output-format=json</code> we will print out more raw statistics for you to search/analyze.</p>
<p>Most projects will have unreadably complex build graphs, so you may want to use the global
<code>--filter-graph</code> argument to narrow your focus on an interesting subgraph. <code>--filter-graph</code> is
applied <em>before</em> doing any semantic analysis, so if you filter out a package and it was the problem,
the problem will disappear. This can be used to bisect a problem if you get ambitious enough with
your filters.</p>
<h3 id="usage-16"><a class="header" href="#usage-16">USAGE</a></h3>
<pre><code>cargo vet dump-graph [OPTIONS]
</code></pre>
<h3 id="options-15"><a class="header" href="#options-15">OPTIONS</a></h3>
<h4 id="--depth-depth"><a class="header" href="#--depth-depth"><code>--depth &lt;DEPTH&gt;</code></a></h4>
<p>The depth of the graph to print (for a large project, the full graph is a HUGE MESS)</p>
<p>[default: first-party]<br />
[possible values: roots, workspace, first-party, first-party-and-directs, full]</p>
<h4 id="-h---help-15"><a class="header" href="#-h---help-15"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-16"><a class="header" href="#global-options-16">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-gc"><a class="header" href="#cargo-vet-gc">cargo vet gc</a></h2>
<p>Clean up old packages from the vet cache</p>
<p>Removes packages which haven't been accessed in a while, and deletes any extra files which aren't
recognized by cargo-vet.</p>
<p>In the future, many cargo-vet subcommands will implicitly do this.</p>
<h3 id="usage-17"><a class="header" href="#usage-17">USAGE</a></h3>
<pre><code>cargo vet gc [OPTIONS]
</code></pre>
<h3 id="options-16"><a class="header" href="#options-16">OPTIONS</a></h3>
<h4 id="--max-package-age-days-max_package_age_days"><a class="header" href="#--max-package-age-days-max_package_age_days"><code>--max-package-age-days &lt;MAX_PACKAGE_AGE_DAYS&gt;</code></a></h4>
<p>Packages in the vet cache which haven't been used for this many days will be removed</p>
<p>[default: 30]</p>
<h4 id="--clean"><a class="header" href="#--clean"><code>--clean</code></a></h4>
<p>Remove the entire cache directory, forcing it to be regenerated next time you use cargo
vet</p>
<h4 id="-h---help-16"><a class="header" href="#-h---help-16"><code>-h, --help</code></a></h4>
<p>Print help information</p>
<h3 id="global-options-17"><a class="header" href="#global-options-17">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-vet-help-1"><a class="header" href="#cargo-vet-help-1">cargo vet help</a></h2>
<p>Print this message or the help of the given subcommand(s)</p>
<h3 id="usage-18"><a class="header" href="#usage-18">USAGE</a></h3>
<pre><code>cargo vet help [OPTIONS] [SUBCOMMAND]...
</code></pre>
<h3 id="args-6"><a class="header" href="#args-6">ARGS</a></h3>
<h4 id="subcommand-1"><a class="header" href="#subcommand-1"><code>&lt;SUBCOMMAND&gt;...</code></a></h4>
<p>The subcommand whose help message to display</p>
<h3 id="global-options-18"><a class="header" href="#global-options-18">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="commands.html#global-options">global options</a></p>
<p>stderr:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-vetting-works"><a class="header" href="#how-vetting-works">How Vetting Works</a></h1>
<p>This section provides additional detail on the mechanics of <code>cargo vet</code>.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>When vetting dependencies, <code>cargo vet</code> will execute the <code>cargo metadata</code>
subcommand to learn about the crate graph. When traversing the graph, <code>cargo vet</code> will enforce audits for all crates.io dependencies.</p>
<p>All other nodes in the graph are considered trusted and therefore non-auditable:</p>
<ul>
<li>
<p><strong>Root crates and path dependencies:</strong> The source code is typically in the
repository and already subject to normal review policies.</p>
</li>
<li>
<p><strong>Git dependencies:</strong> It is expected that git dependencies have a manual
verification process if necessary, or it's otherwise expected that these are
typically private git repositories anyway.</p>
</li>
<li>
<p><strong>Non-crates.io registry dependencies:</strong> It's expected that a non-default
registry is likely private or has its own review and/or publication policies.
The tool may eventually support this if large public non-crates.io mirrors
emerge.</p>
</li>
</ul>
<h2 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h2>
<p>The following is a very simplified sketch of what happens when <code>cargo vet</code>
is invoked.</p>
<blockquote>
<p><strong>Note</strong>: The details here are still being refined as we iterate on the
implementation, so this section has gaps and may drift out of date.</p>
</blockquote>
<p>First, the project's <a href="./config.html">configuration</a> is be parsed and loaded.</p>
<p>If not running in locked mode, each of the URLs listed in the <code>imports</code> key of
<code>config.toml</code> is then fetched. These files are then processed and the resulting
data is stored in <code>imports.lock</code>. The descriptions for any mapped criteria are
stored as well, and any changes to previously-recorded descriptions will cause
<code>cargo vet</code> to fail and require <code>cargo vet accept-criteria-change</code> to be run.</p>
<p><code>audits.toml</code>, <code>imports.lock</code>, and  <code>config.toml</code> are then parsed. If any of the
three are not well-formed, an error is thrown.</p>
<p>Next, the files are ingested in order into a multi-level table, indexed first by
crate name and then by criteria. Each concrete entry contains a list of absolute
versions, a list of version deltas, a list of violation versions. Each insertion
checks for overlap between the set of audited versions and violation versions;
if overlap is created, an error is thrown.</p>
<p>Next, the dependency subtrees of each top-level crate are traversed in accordance
with the policy specified for each crate. TODO: Precisely specify the subtree
traversal algorithm.</p>
<p>If verification fails, an error is generated, along with a list of any versions
of the same crate that would have passed verification. These can be used as
inputs to <code>cargo vet diff</code>.</p>
<p>If any entries in <code>unaudited</code> are superfluous — i.e. verification would succeed
without them — a warning is generated so that the list can be pared down.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-choice-faq"><a class="header" href="#design-choice-faq">Design Choice FAQ</a></h1>
<p>This section serves to document the rationale behind various design choices and
highlight some alternatives considered. This should be considered supplementary
to the <a href="./rationale.html">Rationale &amp; Design</a> section.</p>
<h2 id="what-about-crates-where-i-trust-the-author"><a class="header" href="#what-about-crates-where-i-trust-the-author">What about crates where I trust the author?</a></h2>
<p>You might find yourself using a crate authored either by someone you personally
know or by a well-known member the community, in which case you might see low
value in an additional audit. In this situation, you are of course free to
simply leave the crate in the <code>unaudited</code> list indefinitely, perhaps with a
<code>suggest = false</code> and note indicating that this specific audit is a low priority.</p>
<p>There are, of course, dangers in being too permissive in these cases. Crates are
often a collaborative effort, and it may not be the case that this trusted
individual personally reviewed every contribution to date and will continue to
do so forever. If the author has the authority to certify audits for your
project, a better approach is to have them contribue the audit directly to your
<code>audits.toml</code>.</p>
<h2 id="why-does-cargo-vet-init-automatically-exempt-all-existing-dependencies"><a class="header" href="#why-does-cargo-vet-init-automatically-exempt-all-existing-dependencies">Why does <code>cargo vet init</code> automatically exempt all existing dependencies?</a></h2>
<p>A key goal of <code>cargo vet</code> is to make it very easy to go from first learning
about the tool to having it running on CI. Having an open-ended task — like
auditing one or more crates — on that critical path increases the chance that
the developer gets side-tracked and never completes the setup. So the idea is to
enable developers to quickly get to a green state, and then use <code>cargo vet suggest</code> to ratchet down the set of unaudited code at their own pace.</p>
<h2 id="why-does-cargo-vet-require-audits-for-overridden-dependencies"><a class="header" href="#why-does-cargo-vet-require-audits-for-overridden-dependencies">Why does <code>cargo vet</code> require audits for overridden dependencies?</a></h2>
<p>Cargo supports <a href="https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html">dependency
overrides</a>,
which allows developers to replace public crates in their dependency graph with
a custom version. Strictly speaking, these overrides are first-party code, but
<code>cargo vet</code> nevertheless requires a corresponding audit for the public version.</p>
<p>The reason is that this custom version might be generated in one of two ways: by
building a semantically-compatible replacement from scratch, or by starting with
the source of the original crate and making some (potentially-minimal)
modifications. The latter case is quite common, and in practice rarely entails a
full audit of the original crate despite formally transforming it into
first-party code.  Since <code>cargo vet</code> has no way to distinguish this case from a
from-scratch rewrite, it conservatively assumes the override is a derivative
work, and requires the original version to be audited. The from-scratch can be
handled by adding an entry to the <code>unaudited</code> table with <code>suggest = false</code> and a
note explaining the situation.</p>
<h2 id="how-does-this-relate-to-cargo-crev"><a class="header" href="#how-does-this-relate-to-cargo-crev">How does this relate to <code>cargo crev</code>?</a></h2>
<p>This work was partially inspired by <code>cargo crev</code>, and borrows some aspects
from its design. We are grateful for its existence and the hard work behind it.
<code>cargo vet</code> makes a few design choices that differ from <code>cargo crev</code>:</p>
<ul>
<li><strong>Project-Oriented:</strong> <code>cargo vet</code> is geared towards usage by organizations,
and therefore does not separate audits by individual developer. Consequently,
it does not have a separate identity and authentication layer.</li>
<li><strong>No Web-of-Trust:</strong> there is no notion of transitive trust. The decision to
trust audits performed by another party is independent of that party's trust
choices, which might be rooted in a different threat model.</li>
<li><strong>Automated Enforcement:</strong> <code>cargo vet</code> is designed to be run as an enforcement
tool for projects to manage (rather than just inspect) their supply chains,
and consequently has a number of affordances in this direction.</li>
<li><strong>Audit Criteria:</strong> <code>cargo vet</code> supports recording
<a href="audit-criteria.html">multiple kinds of audits</a>.</li>
</ul>
<p>Eventually, it could make sense to implement some form of bridging between the
two systems.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
